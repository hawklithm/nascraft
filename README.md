# Nascraft

Nascraft is a web application designed to handle file uploads efficiently using Rust and Actix-web. It supports chunked file uploads, allowing large files to be uploaded in smaller parts, which are then reassembled on the server. This approach is particularly useful for handling unreliable network connections or large file sizes.

## Features

- **Chunked File Uploads**: Upload large files in smaller chunks to improve reliability and performance.
- **File Metadata Management**: Store and manage metadata for each uploaded file, including filename, total size, and checksum.
- **Upload Progress Tracking**: Track the progress of each file upload, ensuring that all parts are received before final assembly.
- **Database Integration**: Use MySQL for storing file metadata and upload progress, with support for database initialization and structure checks.
- **Asynchronous Processing**: Leverage Rust's asynchronous capabilities for efficient file handling and database operations.

## Getting Started

### Prerequisites

- Rust (latest stable version)
- MySQL database
- Cargo (Rust package manager)

### Installation

1. Clone the repository:

   ```bash
   git clone https://github.com/yourusername/nascraft.git
   cd nascraft
   ```

2. Set up the MySQL database:

   - Create a database named `nascraft`.
   - Run the SQL scripts in `init.sql` and `init_sys.sql` to set up the necessary tables.

3. Configure environment variables:

   Create a `.env` file in the project root with the following variables:

   ```env
   DATABASE_URL=mysql://user:password@localhost/nascraft
   LOG_FILE_PATH=logs/nascraft.log
   ```

4. Build and run the application:

   ```bash
   cargo build
   cargo run
   ```

5. Access the application at `http://127.0.0.1:8080`.


### API Endpoints

#### `/submit_metadata`

**Description**: The `/submit_metadata` endpoint is used to submit metadata for a file that is being uploaded. This metadata includes information about the file such as its name and total size. This endpoint is typically called before the actual file upload process begins, allowing the server to prepare for receiving the file in chunks.

**Parameters**:

- **`filename`**: A `String` representing the name of the file being uploaded. This should be the original name of the file as it appears on the user's system.
- **`total_size`**: A `u64` representing the total size of the file in bytes. This is used to determine how many chunks the file will be divided into for upload.

**Example JSON Payload**:

```json
{
    "filename": "example.txt",
    "total_size": 10485760
}
```

**Response**:

The server will respond with a JSON object containing:
- `message`: Success message
- `id`: The unique identifier for the file (automatically generated by the server)
- `total_size`: Total size of the file in bytes
- `chunk_size`: Size of each chunk in bytes (configured on the server)
- `total_chunks`: Total number of chunks
- `chunks`: Array of chunk information, each containing:
  - `start_offset`: Starting byte offset of the chunk
  - `end_offset`: Ending byte offset of the chunk
  - `chunk_size`: Size of this specific chunk in bytes

**Example Response**:
```json
{
    "message": "Metadata submitted successfully",
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "total_size": 10485760,
    "chunk_size": 1048576,
    "total_chunks": 10,
    "chunks": [
        {
            "start_offset": 0,
            "end_offset": 1048575,
            "chunk_size": 1048576
        },
        {
            "start_offset": 1048576,
            "end_offset": 2097151,
            "chunk_size": 1048576
        }
        // ... more chunks
    ]
}
```

**How to Use**:

1. **Prepare the Metadata**: Create a JSON object containing the filename and total size of the file you want to upload.

2. **Send a POST Request**: Use an HTTP client to send a POST request to the `/submit_metadata` endpoint with the JSON payload.

3. **Handle the Response**: The server will respond with detailed information about how to chunk the file for upload, including:
   - A unique file ID to use in subsequent upload requests
   - The size of each chunk
   - The total number of chunks
   - Detailed information about each chunk's byte range

4. **Use Response for Uploads**: Use the chunk information returned in the response to properly segment your file and upload each chunk using the `/upload` endpoint.

**Example Usage with `curl`**:

```bash
curl -X POST http://localhost:8080/submit_metadata \
     -H "Content-Type: application/json" \
     -d '{
           "filename": "example.txt",
           "total_size": 10485760
         }'
```


#### `/upload`

**Description**: The `/upload` endpoint is used to upload a file in chunks. Each chunk is uploaded separately, and the server assembles these chunks into the final file. This endpoint is called multiple times, once for each chunk of the file.

**Headers**:

- **`X-File-ID`**: A header that specifies the unique identifier of the file being uploaded. This should match the `file_id` provided in the `/submit_metadata` call.
- **`X-Start-Offset`**: A header that indicates the starting byte offset of the chunk being uploaded. This helps the server place the chunk correctly in the final file.
- **`Content-Length`**: The length of the chunk being uploaded in bytes.
- **`Content-Range`**: Specifies the byte range of the chunk being uploaded, formatted as `bytes start-end/total`.

**How to Use**:

1. **Prepare the Chunk**: Divide the file into chunks and prepare each chunk for upload. Ensure that each chunk has the correct `X-Start-Offset` and `Content-Range` headers.

2. **Send a POST Request**: Use an HTTP client to send a POST request to the `/upload` endpoint with the chunk data. Include the necessary headers to specify the file ID and byte range.

3. **Handle the Response**: The server will respond with a JSON object indicating the success of the chunk upload. Once all chunks are uploaded, the server will assemble them into the final file.

**Example Usage with `curl`**:

```bash
curl -X POST http://localhost:8080/upload \
     -H "X-File-ID: 123456789" \
     -H "X-Start-Offset: 0" \
     -H "Content-Length: 1048576" \
     -H "Content-Range: bytes 0-1048575/10485760" \
     --data-binary @chunk1.bin
```